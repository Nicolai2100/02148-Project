package BeastBank.yahooAPI;

import org.jspace.*;

import java.io.*;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.*;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

/**
 * This class reads a lot of stocks from the .txtStockFiles folder, and then has multiple threads to evaluate it, and then
 * determines if we want to recommend this to our costumers.
 */
public class StockStream {
    // This space contains files generated by the generate files repository. It has the same amount of
    // Spaces as analyser threads, they will then pull from this repository.
    private static SpaceRepository toBeEvaluatedSpaceRepository;
    // This space contains the final result
    private static RandomSpace evaluatedStockSpace;
    // this repository has to kinds of tuples. A tuple with only a string, which is the name to be analyzed, and
    // at max 1000 tuples with that name, this isn't very lean but this was needed because i cant nest repositorys. I needed to be able to
    // put a repository in a repository but that wasn't possible.
    private static SpaceRepository namesForAnalyzersRepository;
    // This repository just has the names of the stocks. This is required by the evaluator thread since it cant query
    // a repository without knowing the name of the space.
    private static SequentialSpace nameSpace;

    public static void main (String[] args) {
        StockStream stockStream = new StockStream();
        stockStream.startStream();
    }

    public void startStream() {
        System.out.println("Stock stream started evaluation, will notify when done");
        //Creating a File object for directory
        toBeEvaluatedSpaceRepository = new SpaceRepository();
        evaluatedStockSpace = new RandomSpace();
        namesForAnalyzersRepository = new SpaceRepository();
        nameSpace = new SequentialSpace();

        int numofservices = 3;
        // One for each analyzing BeastProject.service.
        for (int i = 0; i < numofservices; i++) {
            getNamesForAnalyzersRepository().add(String.valueOf(i), new SequentialSpace());
        }

        Thread generateFiles = new Thread(() -> {
            try {
                StockStream stockStream = new StockStream();
                final File jarFile = new File(StockStream.class.getProtectionDomain().getCodeSource().getLocation().getPath());
                if (jarFile.isFile())
                    stockStream.generateFileRepositoryJar(numofservices);
                else
                    stockStream.generateFileRepositoryNotJar(numofservices);
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
        Thread analyseStockTrend1 = new Thread(() -> {
            StockStream stockStream = new StockStream();
            while (true) {
                try {
                    if (!stockStream.analyzeStockTrend(0)) break;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        Thread analyseStockTrend2 = new Thread(() -> {
            StockStream stockStream = new StockStream();
            while (true) {
                try {
                    if (!stockStream.analyzeStockTrend(1)) break;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        Thread analyseStockTrend3 = new Thread(() -> {
            StockStream stockStream = new StockStream();
            while (true) {
                try {
                    if (!stockStream.analyzeStockTrend(2)) break;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        Thread recommendstocks = new Thread(() -> {
            StockStream stockStream = new StockStream();
            while (true) {
                    if (!stockStream.calculaterecommandations(3)) break;
            }
            System.out.println("Stockstream finished evaluating, a grand total of " + evaluatedStockSpace.size() + " was evaluated.");
        });
        generateFiles.start();
        analyseStockTrend1.start();
        analyseStockTrend2.start();
        analyseStockTrend3.start();
        recommendstocks.start();
    }

    /**
     * This reads the files and puts the information into the right spaces.
     * @throws IOException
     * @return
     */

    public static ArrayList<String> getResources(final String path) throws IOException {
        final File jarFile = new File(StockStream.class.getProtectionDomain().getCodeSource().getLocation().getPath());
        ArrayList<String> names = new ArrayList();


        final JarFile jar = new JarFile(jarFile);
        final Enumeration<JarEntry> entries = jar.entries(); //gives ALL entries in jar
        while (entries.hasMoreElements()) {
            final String name = entries.nextElement().getName();
            if (name.startsWith(path)) { //filter according to the path
                names.add(name);
            }
        }
        jar.close();
        return names;
    }


    public void generateFileRepositoryJar(int numOfServices) throws IOException {
       // File directoryPath = new File("./txtStockFiles");

        ArrayList<String> names = getResources("txtStockFiles");

        //List of all files and directories
        //File filesList[] = directoryPath.listFiles();
        // Intialize the repository containing a space for each of the threads running
        // Loop over the files
        names.remove(0);
        for (String name : names) {
            // When the file is too long this just gives up and dies
            BufferedReader reader;
            String[] split = name.split("/");

                // input stream
                InputStream is = StockStream.class.getResourceAsStream("/" + name);
                reader = new BufferedReader(new InputStreamReader(is));


            reader.readLine();
            String line;
            int linesread = 0;
            while ((line = reader.readLine()) != null && linesread < 1000) {
                linesread++;
                String[] commasperated = line.split(",");
                try {
                    // Tuple = Dato, start value, number of stocks, might also have to include name;
                    Object[] object = new Object[4];
                    object[0] = split[1];
                    object[1] = commasperated[0];
                    object[2] = Double.valueOf(commasperated[1]);
                    object[3] = Integer.valueOf(commasperated[5]);
                    // Now we add a copy to each space.
                    for (int i = 0; i < numOfServices; i++) {
                        namesForAnalyzersRepository.get(String.valueOf(i)).put(object);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //System.out.println("toBeEvaluatedSpaceRepository got a new entry: " + split[1]);
            toBeEvaluatedSpaceRepository.add(split[1], new SequentialSpace());
            try {
                nameSpace.put(split[1]);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // The files are added to each of the repository when all the tuples are uploaded, else it might happen that the thread only collects some of the tuples.
            for (int i = 0; i < numOfServices; i++) {
                try {
                    namesForAnalyzersRepository.get(String.valueOf(i)).put(split[1]);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        for (int i = 0; i < numOfServices; i++) {
            try {
                namesForAnalyzersRepository.get(String.valueOf(i)).put("kill");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        try {
            nameSpace.put("kill");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void generateFileRepositoryNotJar(int numOfServices) throws IOException {
        File directoryPath = new File("src/main/resources/txtStockFiles");
        //List of all files and directories
        File filesList[] = directoryPath.listFiles();
        // Intialize the repository containing a space for each of the threads running
        // Loop over the files
        for (File file : filesList) {
            // When the file is too long this just gives up and dies
            BufferedReader reader;
            reader = new BufferedReader(new FileReader(file.getAbsolutePath()));
            reader.readLine();
            String line;
            int linesread = 0;
            while ((line = reader.readLine()) != null && linesread < 1000) {
                linesread++;
                String[] commasperated = line.split(",");
                try {
                    // Tuple = Dato, start value, number of stocks, might also have to include name;
                    Object[] object = new Object[4];
                    object[0] = file.getName();
                    object[1] = commasperated[0];
                    object[2] = Double.valueOf(commasperated[1]);
                    object[3] = Integer.valueOf(commasperated[5]);
                    // Now we add a copy to each space.
                    for (int i = 0; i < numOfServices; i++) {
                        namesForAnalyzersRepository.get(String.valueOf(i)).put(object);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            toBeEvaluatedSpaceRepository.add(file.getName(), new SequentialSpace());
            try {
                nameSpace.put(file.getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // The files are added to each of the repository when all the tuples are uploaded, else it might happen that the thread only collects some of the tuples.
            for (int i = 0; i < numOfServices; i++) {
                try {
                    namesForAnalyzersRepository.get(String.valueOf(i)).put(file.getName());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        for (int i = 0; i < numOfServices; i++) {
            try {
                namesForAnalyzersRepository.get(String.valueOf(i)).put("kill");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        try {
            nameSpace.put("kill");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /**
     * Takes a stock from a space and evaluates it.
     * @param threadIdentifier identifier such that it knows which space to query for the stocks.
     * @return a boolean to know when the thread needs to be stopped.
     * @throws InterruptedException
     */
    public boolean analyzeStockTrend(int threadIdentifier) throws InterruptedException {
        boolean recommend;
        // First we do the query to find the space.
        SequentialSpace sequentialSpace = (SequentialSpace) namesForAnalyzersRepository.get(String.valueOf(threadIdentifier));

        Object[] response = sequentialSpace.get(new FormalField(String.class));
            if ((response[0]).equals("kill")) {
                return false;
            }
            String stockname = (String) response[0];
            LinkedList<Object[]> objects = sequentialSpace.getAll(new ActualField(stockname),
                    new FormalField(String.class),
                    new FormalField(Double.class),
                    new FormalField(Integer.class));

            for (Object[] object : objects) {
                // Analysis of the stock is done here.
            }
            recommend = Math.random() > 0.5;
            try {
                if (toBeEvaluatedSpaceRepository.get(stockname) == null) {
                    return true;
                } else {
                    toBeEvaluatedSpaceRepository.get(stockname).put(recommend);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        return true;
    }

    /**
     * Evaluates if we would like to recommend a stock to our costumers, based on what the analyzer threads said.
     * @param numOfServices
     * @return
     */
    public boolean calculaterecommandations(int numOfServices) {
        try {
            String stockrecommandation;
            stockrecommandation = (String) nameSpace.query(new FormalField(String.class))[0];
            if (stockrecommandation != null) {
                if (stockrecommandation.equals("kill")) {
                    return false;
                }
                // We do get and then put back and not query because this is a random space. It is a random space because if all the thread doesn't follow the same order
                // This thread might get stuck at a stock which hasn't been evaluated by all the threads yet.

                // If the space is empty we have to do something about, so we have to assign the space to a variable else we can't handle the errror.
                SequentialSpace sequentialSpace = (SequentialSpace) toBeEvaluatedSpaceRepository.get(stockrecommandation);
                if (sequentialSpace == null) {
                    Thread.sleep(100);
                    calculaterecommandations(numOfServices);
                }
                //Thread.sleep(100);

                List<Object[]> recommandations = toBeEvaluatedSpaceRepository.get(stockrecommandation).queryAll(new FormalField(Boolean.class));
                //System.out.println(stockrecommandation + " had the length of " + recommandations.size());
                if (recommandations.size() == numOfServices) {
                    //recommendStockRepository.get((String) stockrecommandation).getAll(new FormalField(Boolean.class));
                    nameSpace.get(new ActualField(stockrecommandation));
                    double i = 0;
                    for (Object[] object : recommandations) {
                        if ((Boolean) object[0]) {
                            i++;
                        }
                    }
                    boolean recommended = i / numOfServices > 0.5;
                    evaluatedStockSpace.put(stockrecommandation, recommended);
                    toBeEvaluatedSpaceRepository.remove(stockrecommandation);
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return true;
    }

    public static SpaceRepository getNamesForAnalyzersRepository() {
        return namesForAnalyzersRepository;
    }

    public static SpaceRepository getToBeEvaluatedSpaceRepository() {
        return toBeEvaluatedSpaceRepository;
    }

    /**
     * Call this method if you want a random recommandation for a client.
     * @return
     */
    public String getRandomStockRecommandation() {
        Object[] response = evaluatedStockSpace.queryp(new FormalField(String.class), new ActualField(true));
        if (response == null)
            return "NA";
        else
            return (String)  response[0];
    }

    /**
     * This checks if we would like to recommend a stock or not, if we don't know the stock we wont recommend it.
     * @param stock
     * @return
     */
    public boolean isStockRecommended(String stock) {
        Object[] response = evaluatedStockSpace.queryp(new ActualField(stock), new FormalField(boolean.class));
        if (response != null)
            return (boolean) response[1];
        else
            return false;
    }
}


