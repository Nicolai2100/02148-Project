GetLockAndStartProcessing:
    while (true) {
        p4.get(new ActualField("lock"));
        OrderPackage orderPkg = (OrderPackage) p0.get(new FormalField(OrderPackage.class))[0];
        //Some business logic here.
        //If the package doesn't have an ID, then we give it
        //a unique ID and then add each of its orders to a space of orders.

        Stack<OrderPackage> packagesToNotify = new Stack<>();
        //Here we query p5 for signals of packages waiting for notifications,
        //Then we add each package to 'packagesToNotify' that satisfies the condition that it
        //contains at least one order that matches an order from the newly arrived package.

        if (packagesToNotify.isEmpty()) { //if there are no packages to notify.
            p1.put("proceed", orderPkg);
        } else {
            p1.put(orderPkg, packagesToNotify); //If there are packages to notify.
        }
        //Notice that if the package is not new (already has an ID), the
        //stack 'packagesToNotify' will be empty.
    }

NotifyPackageToGoBackInQueue:
    while (true) {
        Object[] res = p1.get(new FormalField(OrderPackage.class), new FormalField(Stack.class));
        OrderPackage pkg = (OrderPackage) res[0];
        Stack packagesToNotify = (Stack) res[1];

        if (packagesToNotify.isEmpty()) { //If there are no packages to notify
            p1.put("proceed", pkg);
        } else {
            //We take one token (package) from p3 and pass it to p0.
            //Then we put a new tuple back in p1.

            OrderPackage pkgToNotify = (OrderPackage) packagesToNotify.pop();
            Object[] pkgres = p3.getp(new ActualField(pkgToNotify));
            if (pkgres != null) p0.put(pkgres);
            p1.put(pkg, packagesToNotify);
        }
    }

DiscardDueToExpiration:
    while (true) {
        p0.get(new ActualField("expired"), new FormalField(OrderPackage.class));
    }

TryToFindMatches:
    while (true) {
        OrderPackage orderPkg = (OrderPackage) p1.get(
            new ActualField("go"),
            new FormalField(OrderPackage.class))[1];

        //the method call 'findMatchesForPackage()' executes business logic
        //that tries to find matches for all orders of the package.
        //Returns TRUE if it succeeds, FALSE if not.
        //It also adds all the found matches to a list contained in the package.
        if (findMatchesForPackage(orderPkg)) {
            p2.put(SUCCESS, orderPkg);
        } else {
            p2.put(FAILURE, orderPkg);
        }
    }

RemoveOrdersAndSignalBank:
    while (true) {
        OrderPackage orderPkg = (OrderPackage) p2.get(
            new ActualField(SUCCESS),
            new FormalField(OrderPackage.class))[1];

        //At this point a package has "completed", and we are
        //ready to make transactions.
        //Here we have method calls to business logic that
        //removes all the orders and matching orders
        //from the space. Afterwards we generate a list of
        //transactions and send them to the bank server.

        p4.put("lock");
    }

SignalWaitingForNotification:
    while (true) {
        OrderPackage orderPkg = (OrderPackage) p2.get(
            new ActualField(FAILURE),
            new FormalField(OrderPackage.class))[1];

        //Here we put the package in p3, where it waits to be notified.
        p3.put(orderPkg);

        //Actually, we also put a number of other signals, that tell what kind of
        //orders, the package wants to be notified about.
        for (Order order : orderPkg.getOrders()) {
            p3.put(
                orderPkg.getPackageID(),
                order.getMatchingOrderType(),
                order.getStock(),
                order.getLimit(),
                orderPkg);
        }
        p4.put("lock");
    }


